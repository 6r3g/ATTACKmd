Tactics: [[PERSISTENCE]] - [[PRIVILEGE_ESCALATION]] - [[DEFENSE_EVASION]]
Tags: #mitre/attack/techniques/T1574  

# Hijack Execution Flow - T1574
---
## Description
[more on T1574](https://attack.mitre.org/techniques/T1574)

Adversaries may execute their own malicious payloads by hijacking the way operating systems run programs. Hijacking execution flow can be for the purposes of persistence, since this hijacked execution may reoccur over time. Adversaries may also use these mechanisms to elevate privileges or evade defenses, such as application control or other restrictions on execution.

There are many ways an adversary may hijack the flow of execution, including by manipulating how the operating system locates programs to be executed. How the operating system locates libraries to be used by a program can also be intercepted. Locations where the operating system looks for programs/resources, such as file directories and in the case of Windows the Registry, could also be poisoned to include malicious payloads.

---
## Sub-Techniques

#### DLL Search Order Hijacking - T1574.001
[more on T1574.001](https://attack.mitre.org/techniques/T1574/001)

Adversaries may execute their own malicious payloads by hijacking the search order used to load DLLs. Windows systems use a common method to look for required DLLs to load into a program. [1](https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order?redirectedfrom=MSDN)[2](https://www.fireeye.com/blog/threat-research/2010/07/malware-persistence-windows-registry.html) Hijacking DLL loads may be for the purpose of establishing persistence as well as elevating privileges and/or evading restrictions on file execution.

There are many ways an adversary can hijack DLL loads. Adversaries may plant trojan dynamic-link library files (DLLs) in a directory that will be searched before the location of a legitimate library that will be requested by a program, causing Windows to load their malicious library when it is called for by the victim program. Adversaries may also perform DLL preloading, also called binary planting attacks, [3](https://www.owasp.org/index.php/Binary_planting) by placing a malicious DLL with the same name as an ambiguously specified DLL in a location that Windows searches before the legitimate DLL. Often this location is the current working directory of the program.[4](https://www.fireeye.com/blog/threat-research/2011/06/fxsst.html) Remote DLL preloading attacks occur when a program sets its current directory to a remote location such as a Web share before loading a DLL. [5](https://docs.microsoft.com/en-us/security-updates/securityadvisories/2010/2269637)

Adversaries may also directly modify the search order via DLL redirection, which after being enabled (in the Registry and creation of a redirection file) may cause a program to load a different DLL.[6](https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-redirection?redirectedfrom=MSDN)[7](https://msdn.microsoft.com/en-US/library/aa375365)[8](https://www.fireeye.com/blog/threat-research/2010/08/dll-search-order-hijacking-revisited.html)

If a search order-vulnerable program is configured to run at a higher privilege level, then the adversary-controlled DLL that is loaded will also be executed at the higher level. In this case, the technique could be used for privilege escalation from user to administrator or SYSTEM or from administrator to SYSTEM, depending on the program. Programs that fall victim to path hijacking may appear to behave normally because malicious DLLs may be configured to also load the legitimate DLLs they were meant to replace.

#### DLL Side-Loading - T1574.002
[more on T1574.002](https://attack.mitre.org/techniques/T1574/002)

Adversaries may execute their own malicious payloads by side-loading DLLs. Similar to [[T1574_Hijack Execution Flow#DLL Search Order Hijacking - T1574 001|DLL Search Order Hijacking (T1574.001)]], side-loading involves hijacking which DLL a program loads. But rather than just planting the DLL within the search order of a program then waiting for the victim application to be invoked, adversaries may directly side-load their payloads by planting then invoking a legitimate application that executes their payload(s).

Side-loading takes advantage of the DLL search order used by the loader by positioning both the victim application and malicious payload(s) alongside each other. Adversaries likely use side-loading as a means of masking actions they perform under a legitimate, trusted, and potentially elevated system or software process. Benign executables used to side-load payloads may not be flagged during delivery and/or execution. Adversary payloads may also be encrypted/packed or otherwise obfuscated until loaded into the memory of the trusted process.[1](https://www.fireeye.com/content/dam/fireeye-www/global/en/current-threats/pdfs/rpt-dll-sideloading.pdf)

#### Dylib Hijacking - T1574.004
[more on T1574.004](https://attack.mitre.org/techniques/T1574/004)

Adversaries may execute their own payloads by placing a malicious dynamic library (dylib) with an expected name in a path a victim application searches at runtime. The dynamic loader will try to find the dylibs based on the sequential order of the search paths. Paths to dylibs may be prefixed with `@rpath`, which allows developers to use relative paths to specify an array of search paths used at runtime based on the location of the executable. Additionally, if weak linking is used, such as the `LC_LOAD_WEAK_DYLIB` function, an application will still execute even if an expected dylib is not present. Weak linking enables developers to run an application on multiple macOS versions as new APIs are added.

Adversaries may gain execution by inserting malicious dylibs with the name of the missing dylib in the identified path.[1](https://objective-see.com/blog/blog_0x46.html)[2](https://www.virusbulletin.com/uploads/pdf/magazine/2015/vb201503-dylib-hijacking.pdf)[3](https://github.com/EmpireProject/Empire/blob/master/lib/modules/python/situational_awareness/host/osx/HijackScanner.py)[4](https://github.com/EmpireProject/Empire/blob/08cbd274bef78243d7a8ed6443b8364acd1fc48b/lib/modules/python/persistence/osx/CreateHijacker.py) Dylibs are loaded into an application's address space allowing the malicious dylib to inherit the application's privilege level and resources. Based on the application, this could result in privilege escalation and uninhibited network access. This method may also evade detection from security products since the execution is masked under a legitimate process.[5](https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-For-OS-X.pdf)[6](https://taomm.org/vol1/pdfs.html)[7](https://malwareunicorn.org/workshops/macos_dylib_injection.html#5)

#### Executable Installer File Permissions Weakness - T1574.005
[more on T1574.005](https://attack.mitre.org/techniques/T1574/005)

Adversaries may execute their own malicious payloads by hijacking the binaries used by an installer. These processes may automatically execute specific binaries as part of their functionality or to perform other actions. If the permissions on the file system directory containing a target binary, or permissions on the binary itself, are improperly set, then the target binary may be overwritten with another binary using user-level permissions and executed by the original process. If the original process and thread are running under a higher permissions level, then the replaced binary will also execute under higher-level permissions, which could include SYSTEM.

Another variation of this technique can be performed by taking advantage of a weakness that is common in executable, self-extracting installers. During the installation process, it is common for installers to use a subdirectory within the `%TEMP%` directory to unpack binaries such as DLLs, EXEs, or other payloads. When installers create subdirectories and files they often do not set appropriate permissions to restrict write access, which allows for execution of untrusted code placed in the subdirectories or overwriting of binaries used in the installation process. This behavior is related to and may take advantage of [[T1574_Hijack Execution Flow#DLL Search Order Hijacking - T1574 001|DLL Search Order Hijacking (T1574.001)]].

Adversaries may use this technique to replace legitimate binaries with malicious ones as a means of executing code at a higher permissions level. Some installers may also require elevated privileges that will result in privilege escalation when executing adversary controlled code. This behavior is related to [[T1548_Abuse Elevation Control Mechanism#Bypass User Account Control - T1548 002|Bypass User Account Control (T1548.002)]]. Several examples of this weakness in existing common installers have been reported to software vendors.[1](https://www.mozilla.org/en-US/security/advisories/mfsa2012-98/) [2](https://seclists.org/fulldisclosure/2015/Dec/34) If the executing process is set to run at a specific time or during a certain event (e.g., system bootup) then this technique can also be used for persistence.

#### Dynamic Linker Hijacking - T1574.006
[more on T1574.006](https://attack.mitre.org/techniques/T1574/006)

Adversaries may execute their own malicious payloads by hijacking environment variables the dynamic linker uses to load shared libraries. During the execution preparation phase of a program, the dynamic linker loads specified absolute paths of shared libraries from environment variables and files, such as `LD_PRELOAD` on Linux or `DYLD_INSERT_LIBRARIES` on macOS. Libraries specified in environment variables are loaded first, taking precedence over system libraries with the same function name.[1](https://www.man7.org/linux/man-pages/man8/ld.so.8.html)[2](https://www.tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html)[3](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html) These variables are often used by developers to debug binaries without needing to recompile, deconflict mapped symbols, and implement custom functions without changing the original library.[4](https://www.baeldung.com/linux/ld_preload-trick-what-is)

On Linux and macOS, hijacking dynamic linker variables may grant access to the victim process's memory, system/network resources, and possibly elevated privileges. This method may also evade detection from security products since the execution is masked under a legitimate process. Adversaries can set environment variables via the command line using the `export` command, `setenv` function, or `putenv` function. Adversaries can also leverage [[T1574_Hijack Execution Flow#Dynamic Linker Hijacking - T1574 006|Dynamic Linker Hijacking (T1574.006)]] to export variables in a shell or set variables programmatically using higher level syntax such Python’s `os.environ`.

On Linux, adversaries may set `LD_PRELOAD` to point to malicious libraries that match the name of legitimate libraries which are requested by a victim program, causing the operating system to load the adversary's malicious code upon execution of the victim program. `LD_PRELOAD` can be set via the environment variable or `/etc/ld.so.preload` file.[1](https://www.man7.org/linux/man-pages/man8/ld.so.8.html)[2](https://www.tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html) Libraries specified by `LD_PRELOAD` are loaded and mapped into memory by `dlopen()` and `mmap()` respectively.[5](https://www.datawire.io/code-injection-on-linux-and-macos/)[6](http://hick.org/code/skape/papers/needle.txt) [7](http://phrack.org/issues/51/8.html)[8](http://www.nth-dimension.org.uk/pub/BTL.pdf)

On macOS this behavior is conceptually the same as on Linux, differing only in how the macOS dynamic libraries (dyld) is implemented at a lower level. Adversaries can set the `DYLD_INSERT_LIBRARIES` environment variable to point to malicious libraries containing names of legitimate libraries or functions requested by a victim program.[9](https://theevilbit.github.io/posts/dyld_insert_libraries_dylib_injection_in_macos_osx_deep_dive/)[10](https://blog.timac.org/2012/1218-simple-code-injection-using-dyld_insert_libraries/)[11](https://jon-gabilondo-angulo-7635.medium.com/how-to-inject-code-into-mach-o-apps-part-ii-ddb13ebc8191)

#### Path Interception by PATH Environment Variable - T1574.007
[more on T1574.007](https://attack.mitre.org/techniques/T1574/007)

Adversaries may execute their own malicious payloads by hijacking environment variables used to load libraries. Adversaries may place a program in an earlier entry in the list of directories stored in the PATH environment variable, which Windows will then execute when it searches sequentially through that PATH listing in search of the binary that was called from a script or the command line.

The PATH environment variable contains a list of directories. Certain methods of executing a program (namely using cmd.exe or the command-line) rely solely on the PATH environment variable to determine the locations that are searched for a program when the path for the program is not given. If any directories are listed in the PATH environment variable before the Windows directory, `%SystemRoot%\system32` (e.g., `C:\Windows\system32`), a program may be placed in the preceding directory that is named the same as a Windows program (such as cmd, PowerShell, or Python), which will be executed when that command is executed from a script or command-line.

For example, if `C:\example path` precedes C:\Windows\system32 is in the PATH environment variable, a program that is named net.exe and placed in `C:\example path` will be called instead of the Windows system "net" when "net" is executed from the command-line.

#### Path Interception by Search Order Hijacking - T1574.008
[more on T1574.008](https://attack.mitre.org/techniques/T1574/008)

Adversaries may execute their own malicious payloads by hijacking the search order used to load other programs. Because some programs do not call other programs using the full path, adversaries may place their own file in the directory where the calling program is located, causing the operating system to launch their malicious software at the request of the calling program.

Search order hijacking occurs when an adversary abuses the order in which Windows searches for programs that are not given a path. Unlike [[T1574_Hijack Execution Flow#DLL Search Order Hijacking - T1574 001|DLL Search Order Hijacking (T1574.001)]], the search order differs depending on the method that is used to execute the program. [1](http://msdn.microsoft.com/en-us/library/ms682425) [2](https://docs.microsoft.com/en-us/previous-versions//cc723564(v=technet.10)?redirectedfrom=MSDN#XSLTsection127121120120) [3](http://msdn.microsoft.com/en-us/library/ms687393) However, it is common for Windows to search in the directory of the initiating program before searching through the Windows system directory. An adversary who finds a program vulnerable to search order hijacking (i.e., a program that does not specify the path to an executable) may take advantage of this vulnerability by creating a program named after the improperly specified program and placing it within the initiating program's directory.

For example, "example.exe" runs "cmd.exe" with the command-line argument `net user`. An adversary may place a program called "net.exe" within the same directory as example.exe, "net.exe" will be run instead of the Windows system utility net. In addition, if an adversary places a program called "net.com" in the same directory as "net.exe", then `cmd.exe /C net user` will execute "net.com" instead of "net.exe" due to the order of executable extensions defined under PATHEXT. [4](https://docs.microsoft.com/en-us/previous-versions//fd7hxfdd(v=vs.85)?redirectedfrom=MSDN)

Search order hijacking is also a common practice for hijacking DLL loads and is covered in [[T1574_Hijack Execution Flow#DLL Search Order Hijacking - T1574 001|DLL Search Order Hijacking (T1574.001)]].

#### Path Interception by Unquoted Path - T1574.009
[more on T1574.009](https://attack.mitre.org/techniques/T1574/009)

Adversaries may execute their own malicious payloads by hijacking vulnerable file path references. Adversaries can take advantage of paths that lack surrounding quotations by placing an executable in a higher level directory within the path, so that Windows will choose the adversary's executable to launch.

Service paths [1](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/hklm-system-currentcontrolset-services-registry-tree) and shortcut paths may also be vulnerable to path interception if the path has one or more spaces and is not surrounded by quotation marks (e.g., `C:\unsafe path with space\program.exe` vs. `"C:\safe path with space\program.exe"`). [2](https://isc.sans.edu/diary/Help+eliminate+unquoted+path+vulnerabilities/14464) (stored in Windows Registry keys) An adversary can place an executable in a higher level directory of the path, and Windows will resolve that executable instead of the intended executable. For example, if the path in a shortcut is `C:\program files\myapp.exe`, an adversary may create a program at `C:\program.exe` that will be run instead of the intended program. [3](https://securityboulevard.com/2018/04/windows-privilege-escalation-unquoted-services/) [4](https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/)

This technique can be used for persistence if executables are called on a regular basis, as well as privilege escalation if intercepted executables are started by a higher privileged process.

#### Service File Permissions Weakness - T1574.010
[more on T1574.010](https://attack.mitre.org/techniques/T1574/010)

Adversaries may execute their own malicious payloads by hijacking the binaries used by services. Adversaries may use flaws in the permissions of Windows services to replace the binary that is executed upon service start. These service processes may automatically execute specific binaries as part of their functionality or to perform other actions. If the permissions on the file system directory containing a target binary, or permissions on the binary itself are improperly set, then the target binary may be overwritten with another binary using user-level permissions and executed by the original process. If the original process and thread are running under a higher permissions level, then the replaced binary will also execute under higher-level permissions, which could include SYSTEM.

Adversaries may use this technique to replace legitimate binaries with malicious ones as a means of executing code at a higher permissions level. If the executing process is set to run at a specific time or during a certain event (e.g., system bootup) then this technique can also be used for persistence.

#### Services Registry Permissions Weakness - T1574.011
[more on T1574.011](https://attack.mitre.org/techniques/T1574/011)

Adversaries may execute their own malicious payloads by hijacking the Registry entries used by services. Adversaries may use flaws in the permissions for Registry keys related to services to redirect from the originally specified executable to one that they control, in order to launch their own code when a service starts. Windows stores local service configuration information in the Registry under `HKLM\SYSTEM\CurrentControlSet\Services`. The information stored under a service's Registry keys can be manipulated to modify a service's execution parameters through tools such as the service controller, sc.exe, [[T1059_Command and Scripting Interpreter#PowerShell - T1059 001|PowerShell (T1059.001)]], or [Reg](https://attack.mitre.org/software/S0075). Access to Registry keys is controlled through access control lists and user permissions. [1](https://docs.microsoft.com/en-us/windows/win32/sysinfo/registry-key-security-and-access-rights?redirectedfrom=MSDN)[2](https://www.bleepingcomputer.com/tutorials/how-malware-hides-as-a-service/)

If the permissions for users and groups are not properly set and allow access to the Registry keys for a service, adversaries may change the service's binPath/ImagePath to point to a different executable under their control. When the service starts or is restarted, then the adversary-controlled program will execute, allowing the adversary to establish persistence and/or privilege escalation to the account context the service is set to execute under (local/domain account, SYSTEM, LocalService, or NetworkService).

Adversaries may also alter other Registry keys in the service’s Registry tree. For example, the `FailureCommand` key may be changed so that the service is executed in an elevated context anytime the service fails or is intentionally corrupted.[3](https://trustedsignal.blogspot.com/2014/05/kansa-service-related-collectors-and.html)[4](https://twitter.com/r0wdy_/status/936365549553991680)

The `Performance` key contains the name of a driver service's performance DLL and the names of several exported functions in the DLL.[5](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/hklm-system-currentcontrolset-services-registry-tree) If the `Performance` key is not already present and if an adversary-controlled user has the `Create Subkey` permission, adversaries may create the `Performance` key in the service’s Registry tree to point to a malicious DLL.[6](https://itm4n.github.io/windows-registry-rpceptmapper-eop/)

Adversaries may also add the `Parameters` key, which stores driver-specific data, or other custom subkeys for their malicious services to establish persistence or enable other malicious activities.[5](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/hklm-system-currentcontrolset-services-registry-tree)[7](https://www.trendmicro.com/vinfo/us/threat-encyclopedia/malware/troj_zegost) Additionally, If adversaries launch their malicious services using svchost.exe, the service’s file may be identified using `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\servicename\Parameters\ServiceDll`.[2](https://www.bleepingcomputer.com/tutorials/how-malware-hides-as-a-service/)

#### COR_PROFILER - T1574.012
[more on T1574.012](https://attack.mitre.org/techniques/T1574/012)

Adversaries may leverage the COR_PROFILER environment variable to hijack the execution flow of programs that load the .NET CLR. The COR_PROFILER is a .NET Framework feature which allows developers to specify an unmanaged (or external of .NET) profiling DLL to be loaded into each .NET process that loads the Common Language Runtime (CLR). These profilers are designed to monitor, troubleshoot, and debug managed code executed by the .NET CLR.[1](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/profiling-overview)[2](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ee471451(v=vs.100))

The COR_PROFILER environment variable can be set at various scopes (system, user, or process) resulting in different levels of influence. System and user-wide environment variable scopes are specified in the Registry, where a [[T1559_Inter-Process Communication#Component Object Model - T1559 001|Component Object Model (T1559.001)]] (COM) object can be registered as a profiler DLL. A process scope COR_PROFILER can also be created in-memory without modifying the Registry. Starting with .NET Framework 4, the profiling DLL does not need to be registered as long as the location of the DLL is specified in the COR_PROFILER_PATH environment variable.[2](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ee471451(v=vs.100))

Adversaries may abuse COR_PROFILER to establish persistence that executes a malicious DLL in the context of all .NET processes every time the CLR is invoked. The COR_PROFILER can also be used to elevate privileges (ex: [[T1548_Abuse Elevation Control Mechanism#Bypass User Account Control - T1548 002|Bypass User Account Control (T1548.002)]]) if the victim .NET process executes at a higher permission level, as well as to hook and [[T1562_Impair Defenses|Impair Defenses (T1562)]] provided by .NET processes.[3](https://redcanary.com/blog/blue-mockingbird-cryptominer/)[4](https://redcanary.com/blog/cor_profiler-for-persistence/)[5](https://offsec.almond.consulting/UAC-bypass-dotnet.html)[6](https://github.com/OmerYa/Invisi-Shell)[7](https://web.archive.org/web/20170720041203/http://subt0x10.blogspot.com/2017/05/subvert-clr-process-listing-with-net.html)

#### KernelCallbackTable - T1574.013
[more on T1574.013](https://attack.mitre.org/techniques/T1574/013)

Adversaries may abuse the `KernelCallbackTable` of a process to hijack its execution flow in order to run their own payloads. [1](https://blog.malwarebytes.com/threat-intelligence/2022/01/north-koreas-lazarus-apt-leverages-windows-update-client-github-in-latest-campaign/) [2](https://www.microsoft.com/security/blog/2018/03/01/finfisher-exposed-a-researchers-tale-of-defeating-traps-tricks-and-complex-virtual-machines/) The `KernelCallbackTable` can be found in the Process Environment Block (PEB) and is initialized to an array of graphic functions available to a GUI process once `user32.dll` is loaded. [3](https://modexp.wordpress.com/2019/05/25/windows-injection-finspy/)

An adversary may hijack the execution flow of a process using the `KernelCallbackTable` by replacing an original callback function with a malicious payload. Modifying callback functions can be achieved in various ways involving related behaviors such as [[T1620_Reflective Code Loading|Reflective Code Loading]] or [[T1055_Process Injection|Process Injection]] into another process.

A pointer to the memory address of the `KernelCallbackTable` can be obtained by locating the PEB (ex: via a call to the `NtQueryInformationProcess()` [[T1106_Native API|Native API]] function). [4](https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess) Once the pointer is located, the `KernelCallbackTable` can be duplicated, and a function in the table (e.g., `fnCOPYDATA`) set to the address of a malicious payload (ex: via `WriteProcessMemory()`). The PEB is then updated with the new address of the table. Once the tampered function is invoked, the malicious payload will be triggered. [1](https://blog.malwarebytes.com/threat-intelligence/2022/01/north-koreas-lazarus-apt-leverages-windows-update-client-github-in-latest-campaign/)

The tampered function is typically invoked using a Windows message. After the process is hijacked and malicious code is executed, the `KernelCallbackTable` may also be restored to its original state by the rest of the malicious payload. [1](https://blog.malwarebytes.com/threat-intelligence/2022/01/north-koreas-lazarus-apt-leverages-windows-update-client-github-in-latest-campaign/) Use of the `KernelCallbackTable` to hijack execution flow may evade detection from security products since the execution can be masked under a legitimate process.

#### AppDomainManager - T1574.014
[more on T1574.014](https://attack.mitre.org/techniques/T1574/014)

Adversaries may execute their own malicious payloads by hijacking how the .NET `AppDomainManager` loads assemblies. The .NET framework uses the `AppDomainManager` class to create and manage one or more isolated runtime environments (called application domains) inside a process to host the execution of .NET applications. Assemblies (`.exe` or `.dll` binaries compiled to run as .NET code) may be loaded into an application domain as executable code. [1](https://learn.microsoft.com/dotnet/framework/app-domains/application-domains)

Known as "AppDomainManager injection," adversaries may execute arbitrary code by hijacking how .NET applications load assemblies. For example, malware may create a custom application domain inside a target process to load and execute an arbitrary assembly. Alternatively, configuration files (`.config`) or process environment variables that define .NET runtime settings may be tampered with to instruct otherwise benign .NET applications to load a malicious assembly (identified by name) into the target process. [2](https://pentestlaboratories.com/2020/05/26/appdomainmanager-injection-and-detection/) [3](https://www.pwc.com/gx/en/issues/cybersecurity/cyber-threat-intelligence/yellow-liderc-ships-its-scripts-delivers-imaploader-malware.html) [4](https://www.rapid7.com/blog/post/2023/05/05/appdomain-manager-injection-new-techniques-for-red-teams/)

