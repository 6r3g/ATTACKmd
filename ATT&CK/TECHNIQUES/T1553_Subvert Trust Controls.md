Tactics: [[DEFENSE_EVASION]]
Tags: #mitre/attack/techniques/T1553  

# Subvert Trust Controls - T1553
---
## Description
[more on T1553](https://attack.mitre.org/techniques/T1553)

Adversaries may undermine security controls that will either warn users of untrusted activity or prevent execution of untrusted programs. Operating systems and security products may contain mechanisms to identify programs or websites as possessing some level of trust. Examples of such features would include a program being allowed to run because it is signed by a valid code signing certificate, a program prompting the user with a warning because it has an attribute set from being downloaded from the Internet, or getting an indication that you are about to connect to an untrusted site.

Adversaries may attempt to subvert these trust mechanisms. The method adversaries use will depend on the specific mechanism they seek to subvert. Adversaries may conduct [[T1222_File and Directory Permissions Modification|File and Directory Permissions Modification (T1222)]] or [[T1112_Modify Registry|Modify Registry (T1112)]] in support of subverting these controls.[1](https://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf) Adversaries may also create or steal code signing certificates to acquire trust on target systems.[2](https://securelist.com/why-you-shouldnt-completely-trust-files-signed-with-digital-certificates/68593/)[3](http://www.symantec.com/connect/blogs/how-attackers-steal-private-keys-digital-certificates)

---
## Sub-Techniques

#### Gatekeeper Bypass - T1553.001
[more on T1553.001](https://attack.mitre.org/techniques/T1553/001)

Adversaries may modify file attributes that signify programs are from untrusted sources to subvert Gatekeeper controls in macOS. When documents, applications, or programs are downloaded an extended attribute (xattr) called `com.apple.quarantine` can be set on the file by the application performing the download. This attribute, also known as a quarantine flag, is read by Apple's Gatekeeper defense program when the file is run and provides a prompt to the user to allow or deny execution. Gatekeeper also monitors an application's usage of dynamic libraries (dylibs) loaded outside the application folder on any quarantined binary, often using the `dlopen` function. If the quarantine flag is set in macOS 10.15+, Gatekeeper also checks for a notarization ticket and sends a cryptographic hash to Apple's servers to check for validity for all unsigned executables.[1](https://eclecticlight.co/2020/08/28/how-notarization-works/)[2](https://blog.malwarebytes.com/cybercrime/2015/10/bypassing-apples-gatekeeper/)

The quarantine flag is an opt-in system and not imposed by macOS. If an application opts-in, a file downloaded from the Internet will be given a quarantine flag before being saved to disk. Any application or user with write permissions to the file can change or strip the quarantine flag. With elevated permission (sudo), this attribute can be removed from any file. The presence of the `com.apple.quarantine` quarantine flag can be checked with the xattr command `xattr -l /path/to/examplefile`. Similarly, this attribute can be recursively removed from all files in a folder using xattr, `sudo xattr -d com.apple.quarantine /path/to/folder`.[3](https://labs.sentinelone.com/20-common-tools-techniques-used-by-macos-threat-actors-malware/)[4](https://eclecticlight.co/2020/10/29/quarantine-and-the-quarantine-flag/)[5](https://theevilbit.github.io/posts/gatekeeper_not_a_bypass/)

Apps and files loaded onto the system from a USB flash drive, optical disk, external hard drive, from a drive shared over the local network, or using the `curl` command do not set this flag. Additionally, it is possible to avoid setting this flag using [[T1189_Drive-by Compromise|Drive-by Compromise (T1189)]], which may bypass Gatekeeper. [6](https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf)[7](https://derflounder.wordpress.com/2012/11/20/clearing-the-quarantine-extended-attribute-from-downloaded-applications/)[8](https://www.alienvault.com/blogs/labs-research/oceanlotus-for-os-x-an-application-bundle-pretending-to-be-an-adobe-flash-update)

#### Code Signing - T1553.002
[more on T1553.002](https://attack.mitre.org/techniques/T1553/002)

Adversaries may create, acquire, or steal code signing materials to sign their malware or tools. Code signing provides a level of authenticity on a binary from the developer and a guarantee that the binary has not been tampered with. [1](https://en.wikipedia.org/wiki/Code_signing) The certificates used during an operation may be created, acquired, or stolen by the adversary. [2](https://securelist.com/why-you-shouldnt-completely-trust-files-signed-with-digital-certificates/68593/) [3](http://www.symantec.com/connect/blogs/how-attackers-steal-private-keys-digital-certificates) Unlike [[T1036_Masquerading#Invalid Code Signature - T1036 001|Invalid Code Signature (T1036.001)]], this activity will result in a valid signature.

Code signing to verify software on first run can be used on modern Windows and macOS/OS X systems. It is not used on Linux due to the decentralized nature of the platform. [1](https://en.wikipedia.org/wiki/Code_signing)

Code signing certificates may be used to bypass security policies that require signed code to execute on a system.

#### SIP and Trust Provider Hijacking - T1553.003
[more on T1553.003](https://attack.mitre.org/techniques/T1553/003)

Adversaries may tamper with SIP and trust provider components to mislead the operating system and application control tools when conducting signature validation checks. In user mode, Windows Authenticode [1](https://msdn.microsoft.com/library/ms537359.aspx) digital signatures are used to verify a file's origin and integrity, variables that may be used to establish trust in signed code (ex: a driver with a valid Microsoft signature may be handled as safe). The signature validation process is handled via the WinVerifyTrust application programming interface (API) function, [2](https://msdn.microsoft.com/library/windows/desktop/aa388208.aspx) which accepts an inquiry and coordinates with the appropriate trust provider, which is responsible for validating parameters of a signature. [3](https://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf)

Because of the varying executable file types and corresponding signature formats, Microsoft created software components called Subject Interface Packages (SIPs) [4](https://blogs.technet.microsoft.com/eduardonavarro/2008/07/11/sips-subject-interface-package-and-authenticode/) to provide a layer of abstraction between API functions and files. SIPs are responsible for enabling API functions to create, retrieve, calculate, and verify signatures. Unique SIPs exist for most file formats (Executable, PowerShell, Installer, etc., with catalog signing providing a catch-all [5](https://docs.microsoft.com/windows-hardware/drivers/install/catalog-files)) and are identified by globally unique identifiers (GUIDs). [3](https://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf)

Similar to [[T1553_Subvert Trust Controls#Code Signing - T1553 002|Code Signing (T1553.002)]], adversaries may abuse this architecture to subvert trust controls and bypass security policies that allow only legitimately signed code to execute on a system. Adversaries may hijack SIP and trust provider components to mislead operating system and application control tools to classify malicious (or any) code as signed by: [3](https://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf)

-   Modifying the `Dll` and `FuncName` Registry values in `HKLM\SOFTWARE[\WOW6432Node]Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllGetSignedDataMsg{{SIP_GUID}}` that point to the dynamic link library (DLL) providing a SIP’s CryptSIPDllGetSignedDataMsg function, which retrieves an encoded digital certificate from a signed file. By pointing to a maliciously-crafted DLL with an exported function that always returns a known good signature value (ex: a Microsoft signature for Portable Executables) rather than the file’s real signature, an adversary can apply an acceptable signature value to all files using that SIP [6](https://github.com/mattifestation/PoCSubjectInterfacePackage) (although a hash mismatch will likely occur, invalidating the signature, since the hash returned by the function will not match the value computed from the file).
-   Modifying the `Dll` and `FuncName` Registry values in `HKLM\SOFTWARE[WOW6432Node]Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData{{SIP_GUID}}` that point to the DLL providing a SIP’s CryptSIPDllVerifyIndirectData function, which validates a file’s computed hash against the signed hash value. By pointing to a maliciously-crafted DLL with an exported function that always returns TRUE (indicating that the validation was successful), an adversary can successfully validate any file (with a legitimate signature) using that SIP [6](https://github.com/mattifestation/PoCSubjectInterfacePackage) (with or without hijacking the previously mentioned CryptSIPDllGetSignedDataMsg function). This Registry value could also be redirected to a suitable exported function from an already present DLL, avoiding the requirement to drop and execute a new file on disk.
-   Modifying the `DLL` and `Function` Registry values in `HKLM\SOFTWARE[WOW6432Node]Microsoft\Cryptography\Providers\Trust\FinalPolicy{{trust provider GUID}}` that point to the DLL providing a trust provider’s FinalPolicy function, which is where the decoded and parsed signature is checked and the majority of trust decisions are made. Similar to hijacking SIP’s CryptSIPDllVerifyIndirectData function, this value can be redirected to a suitable exported function from an already present DLL or a maliciously-crafted DLL (though the implementation of a trust provider is complex).
-   **Note:** The above hijacks are also possible without modifying the Registry via [[T1574_Hijack Execution Flow#DLL Search Order Hijacking - T1574 001|DLL Search Order Hijacking (T1574.001)]].

Hijacking SIP or trust provider components can also enable persistent code execution, since these malicious components may be invoked by any application that performs code signing or signature validation. [3](https://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf)

#### Install Root Certificate - T1553.004
[more on T1553.004](https://attack.mitre.org/techniques/T1553/004)

Adversaries may install a root certificate on a compromised system to avoid warnings when connecting to adversary controlled web servers. Root certificates are used in public key cryptography to identify a root certificate authority (CA). When a root certificate is installed, the system or application will trust certificates in the root's chain of trust that have been signed by the root certificate.[1](https://en.wikipedia.org/wiki/Root_certificate) Certificates are commonly used for establishing secure TLS/SSL communications within a web browser. When a user attempts to browse a website that presents a certificate that is not trusted an error message will be displayed to warn the user of the security risk. Depending on the security settings, the browser may not allow the user to establish a connection to the website.

Installation of a root certificate on a compromised system would give an adversary a way to degrade the security of that system. Adversaries have used this technique to avoid security warnings prompting users when compromised systems connect over HTTPS to adversary controlled web servers that spoof legitimate websites in order to collect login credentials.[2](http://www.trendmicro.com/cloud-content/us/pdfs/security-intelligence/white-papers/wp-finding-holes-operation-emmental.pdf)

Atypical root certificates have also been pre-installed on systems by the manufacturer or in the software supply chain and were used in conjunction with malware/adware to provide [[T1557_Adversary-in-the-Middle|Adversary-in-the-Middle (T1557)]] capability for intercepting information transmitted over secure TLS/SSL communications.[3](https://www.kaspersky.com/blog/lenovo-pc-with-adware-superfish-preinstalled/7712/)

Root certificates (and their associated chains) can also be cloned and reinstalled. Cloned certificate chains will carry many of the same metadata characteristics of the source and can be used to sign malicious code that may then bypass signature validation tools (ex: Sysinternals, antivirus, etc.) used to block execution and/or uncover artifacts of Persistence.[4](https://posts.specterops.io/code-signing-certificate-cloning-attacks-and-defenses-6f98657fc6ec)

In macOS, the Ay MaMi malware uses `/usr/bin/security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain /path/to/malicious/cert` to install a malicious certificate as a trusted root certificate into the system keychain.[5](https://objective-see.com/blog/blog_0x26.html)

#### Mark-of-the-Web Bypass - T1553.005
[more on T1553.005](https://attack.mitre.org/techniques/T1553/005)

Adversaries may abuse specific file formats to subvert Mark-of-the-Web (MOTW) controls. In Windows, when files are downloaded from the Internet, they are tagged with a hidden NTFS Alternate Data Stream (ADS) named `Zone.Identifier` with a specific value known as the MOTW.[1](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/6e3f7352-d11c-4d76-8c39-2516a9df36e8) Files that are tagged with MOTW are protected and cannot perform certain actions. For example, starting in MS Office 10, if a MS Office file has the MOTW, it will open in Protected View. Executables tagged with the MOTW will be processed by Windows Defender SmartScreen that compares files with an allowlist of well-known executables. If the file in not known/trusted, SmartScreen will prevent the execution and warn the user not to run it.[2](https://medium.com/swlh/investigating-the-use-of-vhd-files-by-cybercriminals-3f1f08304316)[3](https://outflank.nl/blog/2020/03/30/mark-of-the-web-from-a-red-teams-perspective/)[4](https://www.intezer.com/blog/research/russian-apt-uses-covid-19-lures-to-deliver-zebrocy/)

Adversaries may abuse container files such as compressed/archive (.arj, .gzip) and/or disk image (.iso, .vhd) file formats to deliver malicious payloads that may not be tagged with MOTW. Container files downloaded from the Internet will be marked with MOTW but the files within may not inherit the MOTW after the container files are extracted and/or mounted. MOTW is a NTFS feature and many container files do not support NTFS alternative data streams. After a container file is extracted and/or mounted, the files contained within them may be treated as local files on disk and run without protections.[2](https://medium.com/swlh/investigating-the-use-of-vhd-files-by-cybercriminals-3f1f08304316)[3](https://outflank.nl/blog/2020/03/30/mark-of-the-web-from-a-red-teams-perspective/)

#### Code Signing Policy Modification - T1553.006
[more on T1553.006](https://attack.mitre.org/techniques/T1553/006)

Adversaries may modify code signing policies to enable execution of unsigned or self-signed code. Code signing provides a level of authenticity on a program from a developer and a guarantee that the program has not been tampered with. Security controls can include enforcement mechanisms to ensure that only valid, signed code can be run on an operating system.

Some of these security controls may be enabled by default, such as Driver Signature Enforcement (DSE) on Windows or System Integrity Protection (SIP) on macOS.[1](https://docs.microsoft.com/en-us/previous-versions/windows/hardware/design/dn653559(v=vs.85)?redirectedfrom=MSDN)[2](https://developer.apple.com/documentation/security/disabling_and_enabling_system_integrity_protection) Other such controls may be disabled by default but are configurable through application controls, such as only allowing signed Dynamic-Link Libraries (DLLs) to execute on a system. Since it can be useful for developers to modify default signature enforcement policies during the development and testing of applications, disabling of these features may be possible with elevated permissions.[3](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/installing-an-unsigned-driver-during-development-and-test)[2](https://developer.apple.com/documentation/security/disabling_and_enabling_system_integrity_protection)

Adversaries may modify code signing policies in a number of ways, including through use of command-line or GUI utilities, [[T1112_Modify Registry|Modify Registry (T1112)]], rebooting the computer in a debug/recovery mode, or by altering the value of variables in kernel memory.[4](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/the-testsigning-boot-configuration-option)[2](https://developer.apple.com/documentation/security/disabling_and_enabling_system_integrity_protection)[5](https://www.fireeye.com/blog/threat-research/2012/08/hikit-rootkit-advanced-persistent-attack-techniques-part-2.html)[6](https://github.com/hfiref0x/TDL) Examples of commands that can modify the code signing policy of a system include `bcdedit.exe -set TESTSIGNING ON` on Windows and `csrutil disable` on macOS.[4](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/the-testsigning-boot-configuration-option)[2](https://developer.apple.com/documentation/security/disabling_and_enabling_system_integrity_protection) Depending on the implementation, successful modification of a signing policy may require reboot of the compromised system. Additionally, some implementations can introduce visible artifacts for the user (ex: a watermark in the corner of the screen stating the system is in Test Mode). Adversaries may attempt to remove such artifacts.[7](https://blog-assets.f-secure.com/wp-content/uploads/2019/10/15163408/BlackEnergy_Quedagh.pdf)

To gain access to kernel memory to modify variables related to signature checks, such as modifying `g_CiOptions` to disable Driver Signature Enforcement, adversaries may conduct [[T1068_Exploitation for Privilege Escalation|Exploitation for Privilege Escalation (T1068)]] using a signed, but vulnerable driver.[8](https://unit42.paloaltonetworks.com/acidbox-rare-malware/)[6](https://github.com/hfiref0x/TDL)

