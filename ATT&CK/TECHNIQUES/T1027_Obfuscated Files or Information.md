Tactics: [[DEFENSE_EVASION]]
Tags: #mitre/attack/techniques/T1027  

# Obfuscated Files or Information - T1027
---
## Description
[more on T1027](https://attack.mitre.org/techniques/T1027)

Adversaries may attempt to make an executable or file difficult to discover or analyze by encrypting, encoding, or otherwise obfuscating its contents on the system or in transit. This is common behavior that can be used across different platforms and the network to evade defenses.

Payloads may be compressed, archived, or encrypted in order to avoid detection. These payloads may be used during Initial Access or later to mitigate detection. Sometimes a user's action may be required to open and [[T1140_Deobfuscate-Decode Files or Information|Deobfuscate/Decode Files or Information (T1140)]] for [[T1204_User Execution|User Execution (T1204)]]. The user may also be required to input a password to open a password protected compressed/encrypted file that was provided by the adversary. [1](https://www.volexity.com/blog/2016/11/09/powerduke-post-election-spear-phishing-campaigns-targeting-think-tanks-and-ngos/) Adversaries may also used compressed or archived scripts, such as JavaScript.

Portions of files can also be encoded to hide the plain-text strings that would otherwise help defenders with discovery. [2](https://www.welivesecurity.com/2013/04/26/linuxcdorked-new-apache-backdoor-in-the-wild-serves-blackhole/) Payloads may also be split into separate, seemingly benign files that only reveal malicious functionality when reassembled. [3](https://www.carbonblack.com/2016/09/23/security-advisory-variants-well-known-adware-families-discovered-include-sophisticated-obfuscation-techniques-previously-associated-nation-state-attacks/)

Adversaries may also obfuscate commands executed from payloads or directly via a [[T1059_Command and Scripting Interpreter|Command and Scripting Interpreter (T1059)]]. Environment variables, aliases, characters, and other platform/language specific semantics can be used to evade signature based detections and application control mechanisms. [4](https://www.fireeye.com/blog/threat-research/2017/06/obfuscation-in-the-wild.html) [5](https://www.fireeye.com/content/dam/fireeye-www/blog/pdfs/revoke-obfuscation-report.pdf)[6](https://researchcenter.paloaltonetworks.com/2017/03/unit42-pulling-back-the-curtains-on-encodedcommand-powershell-attacks/)

---
## Sub-Techniques

#### Binary Padding - T1027.001
[more on T1027.001](https://attack.mitre.org/techniques/T1027/001)

Adversaries may use binary padding to add junk data and change the on-disk representation of malware. This can be done without affecting the functionality or behavior of a binary, but can increase the size of the binary beyond what some security tools are capable of handling due to file size limitations.

Binary padding effectively changes the checksum of the file and can also be used to avoid hash-based blocklists and static anti-virus signatures.[1](https://www.welivesecurity.com/2018/03/13/oceanlotus-ships-new-backdoor/) The padding used is commonly generated by a function to create junk data and then appended to the end or applied to sections of malware.[2](https://securelist.com/old-malware-tricks-to-bypass-detection-in-the-age-of-big-data/78010/) Increasing the file size may decrease the effectiveness of certain tools and detection capabilities that are not designed or configured to scan large files. This may also reduce the likelihood of being collected for analysis. Public file scanning services, such as VirusTotal, limits the maximum size of an uploaded file to be analyzed.[3](https://www.virustotal.com/en/faq/)

#### Software Packing - T1027.002
[more on T1027.002](https://attack.mitre.org/techniques/T1027/002)

Adversaries may perform software packing or virtual machine software protection to conceal their code. Software packing is a method of compressing or encrypting an executable. Packing an executable changes the file signature in an attempt to avoid signature-based detection. Most decompression techniques decompress the executable code in memory. Virtual machine software protection translates an executable's original code into a special format that only a special virtual machine can run. A virtual machine is then called to run this code.[1](https://www.welivesecurity.com/wp-content/uploads/2018/01/WP-FinFisher.pdf)

Utilities used to perform software packing are called packers. Example packers are MPRESS and UPX. A more comprehensive list of known packers is available, [2](http://en.wikipedia.org/wiki/Executable_compression) but adversaries may create their own packing techniques that do not leave the same artifacts as well-known packers to evade defenses.

#### Steganography - T1027.003
[more on T1027.003](https://attack.mitre.org/techniques/T1027/003)

Adversaries may use steganography techniques in order to prevent the detection of hidden information. Steganographic techniques can be used to hide data in digital media such as images, audio tracks, video clips, or text files.

[Duqu](https://attack.mitre.org/software/S0038) was an early example of malware that used steganography. It encrypted the gathered information from a victim's system and hid it within an image before exfiltrating the image to a C2 server.[1](https://en.wikipedia.org/wiki/Duqu)

By the end of 2017, a threat group used `Invoke-PSImage` to hide [[T1059_Command and Scripting Interpreter#PowerShell - T1059 001|PowerShell (T1059.001)]] commands in an image file (.png) and execute the code on a victim's system. In this particular case the [[T1059_Command and Scripting Interpreter#PowerShell - T1059 001|PowerShell (T1059.001)]] code downloaded another obfuscated script to gather intelligence from the victim's machine and communicate it back to the adversary.[2](https://securingtomorrow.mcafee.com/mcafee-labs/malicious-document-targets-pyeongchang-olympics/)

#### Compile After Delivery - T1027.004
[more on T1027.004](https://attack.mitre.org/techniques/T1027/004)

Adversaries may attempt to make payloads difficult to discover and analyze by delivering files to victims as uncompiled code. Text-based source code files may subvert analysis and scrutiny from protections targeting executables/binaries. These payloads will need to be compiled before execution; typically via native utilities such as csc.exe or GCC/MinGW.[1](https://www.clearskysec.com/wp-content/uploads/2018/11/MuddyWater-Operations-in-Lebanon-and-Oman.pdf)

Source code payloads may also be encrypted, encoded, and/or embedded within other files, such as those delivered as a [[T1566_Phishing|Phishing (T1566)]]. Payloads may also be delivered in formats unrecognizable and inherently benign to the native OS (ex: EXEs on macOS/Linux) before later being (re)compiled into a proper executable binary with a bundled compiler and execution framework.[2](https://blog.trendmicro.com/trendlabs-security-intelligence/windows-app-runs-on-mac-downloads-info-stealer-and-adware/)

#### Indicator Removal from Tools - T1027.005
[more on T1027.005](https://attack.mitre.org/techniques/T1027/005)

Adversaries may remove indicators from tools if they believe their malicious tool was detected, quarantined, or otherwise curtailed. They can modify the tool by removing the indicator and using the updated version that is no longer detected by the target's defensive systems or subsequent targets that may use similar systems.

A good example of this is when malware is detected with a file signature and quarantined by anti-virus software. An adversary who can determine that the malware was quarantined because of its file signature may modify the file to explicitly avoid that signature, and then re-use the malware.

#### HTML Smuggling - T1027.006
[more on T1027.006](https://attack.mitre.org/techniques/T1027/006)

Adversaries may smuggle data and files past content filters by hiding malicious payloads inside of seemingly benign HTML files. HTML documents can store large binary objects known as JavaScript Blobs (immutable data that represents raw bytes) that can later be constructed into file-like objects. Data may also be stored in Data URLs, which enable embedding media type or MIME files inline of HTML documents. HTML5 also introduced a download attribute that may be used to initiate file downloads.[1](https://www.menlosecurity.com/blog/new-attack-alert-duri)[2](https://outflank.nl/blog/2018/08/14/html-smuggling-explained/)

Adversaries may deliver payloads to victims that bypass security controls through HTML Smuggling by abusing JavaScript Blobs and/or HTML5 download attributes. Security controls such as web content filters may not identify smuggled malicious files inside of HTML/JS files, as the content may be based on typically benign MIME types such as `text/plain` and/or `text/html`. Malicious files or data can be obfuscated and hidden inside of HTML files through Data URLs and/or JavaScript Blobs and can be deobfuscated when they reach the victim (i.e. [[T1140_Deobfuscate-Decode Files or Information|Deobfuscate/Decode Files or Information (T1140)]]), potentially bypassing content filters.

For example, JavaScript Blobs can be abused to dynamically generate malicious files in the victim machine and may be dropped to disk by abusing JavaScript functions such as `msSaveBlob`.[1](https://www.menlosecurity.com/blog/new-attack-alert-duri)[3](https://www.microsoft.com/security/blog/2021/05/27/new-sophisticated-email-based-attack-from-nobelium/)[2](https://outflank.nl/blog/2018/08/14/html-smuggling-explained/)[4](https://research.nccgroup.com/2017/08/08/smuggling-hta-files-in-internet-explorer-edge/)

#### Obfuscated Files or Information: Dynamic API Resolution - T1027.007
[more on T1027.007](https://attack.mitre.org/techniques/T1027/007)

Adversaries may obfuscate then dynamically resolve API functions called by their malware in order to conceal malicious functionalities and impair defensive analysis. Malware commonly uses various [[T1106_Native API|Native API]] functions provided by the OS to perform various tasks such as those involving processes, files, and other system artifacts.

API functions called by malware may leave static artifacts such as strings in payload files. Defensive analysts may also uncover which functions a binary file may execute via an import address table (IAT) or other structures that help dynamically link calling code to the shared modules that provide functions. [1](https://www.huntress.com/blog/hackers-no-hashing-randomizing-api-hashes-to-evade-cobalt-strike-shellcode-detection) [2](https://www.ired.team/offensive-security/defense-evasion/windows-api-hashing-in-malware)

To avoid static or other defensive analysis, adversaries may use dynamic API resolution to conceal malware characteristics and functionalities. Similar to [Software Packing](https://attack.mitre.org/techniques/T1027/002), dynamic API resolution may change file signatures and obfuscate malicious API function calls until they are resolved and invoked during runtime.

Various methods may be used to obfuscate malware calls to API functions. For example, hashes of function names are commonly stored in malware in lieu of literal strings. Malware can use these hashes (or other identifiers) to manually reproduce the linking and loading process using functions such as `GetProcAddress()` and `LoadLibrary()`. These hashes/identifiers can also be further obfuscated using encryption or other string manipulation tricks (requiring various forms of [[T1140_Deobfuscate-Decode Files or Information|Deobfuscate/Decode Files or Information]] during execution). [3](https://www.blackhat.com/docs/us-15/materials/us-15-Choi-API-Deobfuscator-Resolving-Obfuscated-API-Functions-In-Modern-Packers.pdf) [4](https://dr4k0nia.github.io/dotnet/coding/2022/08/10/HInvoke-and-avoiding-PInvoke.html?s=03) [1](https://www.huntress.com/blog/hackers-no-hashing-randomizing-api-hashes-to-evade-cobalt-strike-shellcode-detection)

#### Obfuscated Files or Information: Stripped Payloads - T1027.008
[more on T1027.008](https://attack.mitre.org/techniques/T1027/008)

Adversaries may attempt to make a payload difficult to analyze by removing symbols, strings, and other human readable information. Scripts and executables may contain variables names and other strings that help developers document code functionality. Symbols are often created by an operating system’s `linker` when executable payloads are compiled. Reverse engineers use these symbols and strings to analyze code and to identify functionality in payloads. [1](https://www.mandiant.com/resources/blog/golang-internals-symbol-recovery) [2](https://www.intezer.com/blog/malware-analysis/executable-linkable-format-101-part-2-symbols/)

Adversaries may use stripped payloads in order to make malware analysis more difficult. For example, compilers and other tools may provide features to remove or obfuscate strings and symbols. Adversaries have also used stripped payload formats, such as run-only AppleScripts, a compiled and stripped version of [[T1059_Command and Scripting Interpreter#AppleScript - T1059.002|AppleScript]] , to evade detection and analysis. The lack of human-readable information may directly hinder detection and analysis of payloads. [3](https://www.sentinelone.com/labs/fade-dead-adventures-in-reversing-malicious-run-only-applescripts/)

#### Obfuscated Files or Information: Embedded Payloads - T1027.009
[more on T1027.009](https://attack.mitre.org/techniques/T1027/009)

Adversaries may embed payloads within other files to conceal malicious content from defenses. Otherwise seemingly benign files (such as scripts and executables) may be abused to carry and obfuscate malicious payloads and content. In some cases, embedded payloads may also enable adversaries to [[T1553_Subvert Trust Controls|Subvert Trust Controls]] by not impacting execution controls such as digital signatures and notarization tickets. [1](https://www.sentinelone.com/labs/fade-dead-adventures-in-reversing-malicious-run-only-applescripts/)

Adversaries may embed payloads in various file formats to hide payloads. [2](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/c41e062d-f764-4f13-bd4f-ea812ab9a4d1) This is similar to [[T1027_Obfuscated Files or Information#Steganography - T1027.003|Steganography]], though does not involve weaving malicious content into specific bytes and patterns related to legitimate digital media formats. [3](https://github.com/peewpw/Invoke-PSImage)

For example, adversaries have been observed embedding payloads within or as an overlay of an otherwise benign binary. [4](https://securelist.com/my-name-is-dtrack/93338/) Adversaries have also been observed nesting payloads (such as executables and run-only scripts) inside a file of the same format. [5](https://www.sentinelone.com/labs/fade-dead-adventures-in-reversing-malicious-run-only-applescripts/)

Embedded content may also be used as [[T1055_Process Injection|Process Injection]] payloads used to infect benign system processes. [6](https://www.trendmicro.com/en_us/research/20/e/netwalker-fileless-ransomware-injected-via-reflective-loading.html) These embedded then injected payloads may be used as part of the modules of malware designed to provide specific features such as encrypting C2 communications in support of an orchestrator module. For example, an embedded module may be injected into default browsers, allowing adversaries to then communicate via the network. [7](https://www.cisa.gov/uscert/ncas/analysis-reports/ar20-303a)

#### Obfuscated Files or Information: Command Obfuscation - T1027.010
[more on T1027.010](https://attack.mitre.org/techniques/T1027/010)

Adversaries may obfuscate content during command execution to impede detection. Command-line obfuscation is a method of making strings and patterns within commands and scripts more difficult to signature and analyze. This type of obfuscation can be included within commands executed by delivered payloads (e.g., [[T1566_Phishing|Phishing]] and [[T1189_Drive-by Compromise|Drive-by Compromise]] or interactively via [[T1059_Command and Scripting Interpreter|Command and Scripting Interpreter]]. [1](https://www.akamai.com/blog/security/catch-me-if-you-can-javascript-obfuscation) [2](https://bromiley.medium.com/malware-monday-vbscript-and-vbe-files-292252c1a16)

For example, adversaries may abuse syntax that utilizes various symbols and escape characters (such as spacing, `^`, `+`. `$`, and `%`) to make commands difficult to analyze while maintaining the same intended functionality. [3](https://redcanary.com/threat-detection-report/techniques/powershell/) Many languages support built-in obfuscation in the form of base64 or URL encoding. [4](https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_powershell_exe?view=powershell-5.1#-encodedcommand-base64encodedcommand) Adversaries may also manually implement command obfuscation via string splitting (`"Wor"+"d.Application"`), order and casing of characters (`rev <<<'dwssap/cte/ tac'`), globing (`mkdir -p '/tmp/:&$NiA'`), as well as various tricks involving passing strings through tokens/environment variables/input streams. [5](https://bashfuscator.readthedocs.io/en/latest/Mutators/command_obfuscators/index.html) [6](https://web.archive.org/web/20170923102302/https://www.fireeye.com/blog/threat-research/2017/06/obfuscation-in-the-wild.html)

Adversaries may also use tricks such as directory traversals to obfuscate references to the binary being invoked by a command (`C:\voi\pcw\..\..\Windows\tei\qs\k\..\..\..\system32\erool\..\wbem\wg\je\..\..\wmic.exe shadowcopy delete`). [7](https://twitter.com/rfackroyd/status/1639136000755765254)

Tools such as `Invoke-Obfuscation` and `Invoke-DOSfucation` have also been used to obfuscate commands. [8](https://github.com/danielbohannon/Invoke-DOSfuscation) [9](https://github.com/danielbohannon/Invoke-Obfuscation)

#### Obfuscated Files or Information: Fileless Storage - T1027.011
[more on T1027.011](https://attack.mitre.org/techniques/T1027/011)

Adversaries may store data in "fileless" formats to conceal malicious activity from defenses. Fileless storage can be broadly defined as any format other than a file. Common examples of non-volatile fileless storage include the Windows Registry, event logs, or WMI repository. [1](https://learn.microsoft.com/microsoft-365/security/intelligence/fileless-threats) [2](https://securelist.com/a-new-secret-stash-for-fileless-malware/106393/)

Similar to fileless in-memory behaviors such as [[T1620_Reflective Code Loading|Reflective Code Loading]] and [[T1055_Process Injection|Process Injection]], fileless data storage may remain undetected by anti-virus and other endpoint security tools that can only access specific file formats from disk storage.

Adversaries may use fileless storage to conceal various types of stored data, including payloads/shellcode (potentially being used as part of [[PERSISTENCE|Persistence]]) and collected data not yet exfiltrated from the victim (e.g., [[T1074_Data Staged#Local Data Staging - T1074.001|Local Data Staging]]). Adversaries also often encrypt, encode, splice, or otherwise obfuscate this fileless data when stored.

Some forms of fileless storage activity may indirectly create artifacts in the file system, but in central and otherwise difficult to inspect formats such as the WMI (e.g., `%SystemRoot%\System32\Wbem\Repository`) or Registry (e.g., `%SystemRoot%\System32\Config`) physical files. [1](https://learn.microsoft.com/microsoft-365/security/intelligence/fileless-threats)

####  - T1027.012
[more on T1027.012](https://attack.mitre.org/techniques/T1027/012)

Adversaries may smuggle commands to download malicious payloads past content filters by hiding them within otherwise seemingly benign windows shortcut files. Windows shortcut files (.LNK) include many metadata fields, including an icon location field (also known as the `IconEnvironmentDataBlock`) designed to specify the path to an icon file that is to be displayed for the LNK file within a host directory.

Adversaries may abuse this LNK metadata to download malicious payloads. For example, adversaries have been observed using LNK files as phishing payloads to deliver malware. Once invoked (e.g., [[T1204_User Execution#Malicious File - T1204.002|Malicious File]]), payloads referenced via external URLs within the LNK icon location field may be downloaded. These files may also then be invoked by [[T1059_Command and Scripting Interpreter|Command and Scripting Interpreter]]/[[T1218_Signed Binary Proxy Execution|System Binary Proxy Execution]] arguments within the target path field of the LNK. [1](https://unprotect.it/technique/shortcut-hiding/) [2](https://www.uperesia.com/booby-trapped-shortcut)

LNK Icon Smuggling may also be utilized post compromise, such as malicious scripts executing an LNK on an infected host to download additional malicious payloads.

#### Obfuscated Files or Information: Encrypted/Encoded File - T1027.013
[more on T1027.013](https://attack.mitre.org/techniques/T1027/013)

Adversaries may encrypt or encode files to obfuscate strings, bytes, and other specific patterns to impede detection. Encrypting and/or encoding file content aims to conceal malicious artifacts within a file used in an intrusion. Many other techniques, such as [[T1027_Obfuscated Files or Information#Software Packing - T1027.002|Software Packing]], [[T1027_Obfuscated Files or Information#Steganography - T1027.003|Steganography]], and [[T1027_Obfuscated Files or Information#Obfuscated Files or Information Embedded Payloads - T1027.009|Embedded Payloads]], share this same broad objective. Encrypting and/or encoding files could lead to a lapse in detection of static signatures, only for this malicious content to be revealed (i.e., [[T1140_Deobfuscate-Decode Files or Information|Deobfuscate/Decode Files or Information]]) at the time of execution/use.

This type of file obfuscation can be applied to many file artifacts present on victim hosts, such as malware log/configuration and payload files. [1](https://www.crowdstrike.com/blog/shlayer-malvertising-campaigns-still-using-flash-update-disguise/) Files can be encrypted with a hardcoded or user-supplied key, as well as otherwise obfuscated using standard encoding/compression schemes such as Base64.

The entire content of a file may be obfuscated, or just specific functions or values (such as C2 addresses). Encryption and encoding may also be applied in redundant layers for additional protection.

For example, adversaries may abuse password-protected Word documents or self-extracting (SFX) archives as a method of encrypting/encoding a file such as a [[T1566_Phishing|Phishing]] payload. These files typically function by attaching the intended archived content to a decompressor stub that is executed when the file is invoked (e.g., [[T1204_User Execution|User Execution]]). [2](https://www.crowdstrike.com/blog/self-extracting-archives-decoy-files-and-their-hidden-payloads/)

Adversaries may also abuse file-specific as well as custom encoding schemes. For example, Byte Order Mark (BOM) headers in text files may be abused to manipulate and obfuscate file content until [[T1059_Command and Scripting Interpreter|Command and Scripting Interpreter]] execution.

